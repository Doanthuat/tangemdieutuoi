<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Document</title>

    <style>

        canvas {

            position: absolute;

            left: 0;

            top: 0;

            width: 100%;

            height: 100%;

            background-color: rgba(0, 0, 0, .2);

        }
/*  */
.w_h {
    width: 100%;
    height: 100%;
    position: absolute;
    z-index: 6;
    display: flex;
    align-items: center;
    justify-content: center;
}
/* ---------- */
h1 {
  margin: auto;
  font-family: Gorditas;
  font-size: 6rem;
}

canvas {
  position: absolute;
  left: 0;
  top: 0;
  opacity: 1;
  pointer-events: none;
}
.td-wrapper,
canvas {
  transition: opacity 5s;
}
.td-wrapper:not(.td-hide) + canvas,
.td-hide {
  opacity: 0;
}
    </style>

</head>
<div class="w_h">
    <!-- <h3 style="position: relative;
    color: aliceblue;
    font-family: 'Baloo Tamma', cursive;
    
    
    ">áasassa</h3> -->
  
    <!--  -->
    <h1>
        <span style="color:#ff0000; 
          font-family: 'Baloo Tamma', cursive;
          color: #ffffee;

text-shadow: 0em 0em 0em #ffffff,
             0.1em -0.1em 0.1em #FF4400,
             0.06em -0.2em 0.9em #FF5500,
             0.05em -0.25em 0.4em #FF7700,
             0.04em -0.2em 0.3em #FF7700,
             0.02em -0.15em 0.2em #FF9900,
             0.01em -0.05em 0.15em #FFEE00,
             0.01em -0.02em 0.15em #FFEE00
          ">Diệu</span> <span style="color: rgb(255, 0, 0);
          font-family: 'Baloo Tamma', cursive;
          color: #ff0000;

text-shadow: 0em 0em 0em #ffffff,
             0.1em -0.1em 0.1em #FF4400,
             0.06em -0.2em 0.9em #FF5500,
             0.05em -0.25em 0.4em #FF7700,
             0.04em -0.2em 0.3em #FF7700,
             0.02em -0.15em 0.2em #FF9900,
             0.01em -0.05em 0.15em #FFEE00,
             0.01em -0.02em 0.15em #FFEE00
          ">Tươi</span>
        <!-- <span style="color:#ff0000;
          font-family: 'Baloo Tamma', cursive;
        ">Love</span> -->
      </h1>
  </div>
<body>

    <canvas id="heart"></canvas>


    <script>
          class TextDesintegrator {
  constructor(el, options) {
    const defaultOptions = {
      padding: 160,
      density: 4,
      duration: 2500 // in ms
    };
    this.step = 0;
    this.count = 0;
    this.data = [];
    this.scale = 2; // pixel density
    this.el = el;
    this.el.style.position = "relative";
    this.el.innerHTML = `<span class="td-wrapper">${this.el.textContent}</span>`;
    this.inner = this.el.querySelector("span");
    this.options = { ...defaultOptions, ...options };
    this.reverse = false;
    // copy el to canvas

    document.fonts.ready.then(() => {
      this.createCanvas();
      this.fillCanvas();
      this.pixelize();
      setTimeout(() => {
        this.start();
      }, 0);
    });
  }
  createCanvas() {
    // get the width and the height of the span element
    // canvas will have the same dimensions
    const { width, height } = this.el.getBoundingClientRect();
    this.height = height;
    this.width = width;
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.scale * (this.width + 2 * this.options.padding);
    this.canvas.height = this.scale * (this.height + 2 * this.options.padding);
    this.canvas.style.width = `${this.width + 2 * this.options.padding}px`;
    this.canvas.style.height = `${this.height + 2 * this.options.padding}px`;
    this.canvas.style.transform = `translate3d(${-this.options
      .padding}px, ${-this.options.padding}px, 0)`;
    this.context = this.canvas.getContext("2d");
    this.context.scale(this.scale, this.scale);
    this.el.append(this.canvas);
  }
  clearContext() {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  fillCanvas() {
    const style = getComputedStyle(this.el);
    this.color = style.getPropertyValue("color");
    this.context.fillStyle = this.color;
    this.context.font = style.getPropertyValue("font");
    this.context.textBaseline = "ideographic";
    this.context.fillText(
      this.el.textContent,
      this.options.padding,
      (this.canvas.height / this.scale + this.height) / 2
    );
  }
  start() {
    this.t0 = 0;
    this.id = window.requestAnimationFrame((t) => this.render(t));
  }
  stop() {
    if (this.id) {
      window.cancelAnimationFrame(this.id);
    }
  }
  pixelize() {
    const { padding, density, duration } = this.options;
    for (
      let y = 0;
      y < this.canvas.height + 2 * padding - Math.floor(density / 2);
      y += density
    ) {
      for (
        let x = 0;
        x < this.canvas.width + 2 * padding - Math.floor(density / 2);
        x += density
      ) {
        const { data } = this.context.getImageData(
          x + Math.floor(density / 4),
          y + Math.floor(density / 4),
          1,
          1
        );
        const [, , , a] = data;
        if (a > 0) {
          this.data.push({
            alpha: a / 255,
            longevity: Math.min(
              duration * 0.25 + Math.random() * duration * 0.75,
              duration - 1
            ),
            x,
            y,
            initialX: x,
            initialY: y,
            finalX: x + 2 * (Math.random() - 0.5) * this.canvas.width,
            finalY: y + 2 * (Math.random() - 0.5) * this.canvas.width
          });
        }
      }
    }
  }

  render(timestamp) {
    if (!this.t0) {
      this.t0 = timestamp;
    }
    const elapsed = timestamp - this.t0;
    if (this.step < Math.min(500, this.options.duration * 0.5)) {
      if (this.reverse) {
        this.inner.classList.remove("td-hide");
      } else {
        this.inner.classList.add("td-hide");
      }
    }
    this.updateData();
    this.clearContext();
    for (const sq of this.data) {
      this.context.globalAlpha = sq.alpha;
      this.context.fillStyle = this.color;
      this.context.fillRect(
        sq.x / 2,
        sq.y / 2,
        this.options.density / 2,
        this.options.density / 2
      );
    }
    this.step = this.reverse ? this.options.duration - elapsed : elapsed;
    if (elapsed > this.options.duration) {
      this.onComplete();
    }
    this.id = requestAnimationFrame((t) => this.render(t));
  }
  onComplete() {
    this.reverse = !this.reverse;
    this.t0 = 0;
  }
  updateData() {
    for (const sq of this.data) {
      sq.alpha = this.calculateOpacity(sq.longevity, this.step);
      sq.x = this.calculatePosition(
        sq.initialX,
        sq.finalX,
        sq.longevity,
        this.step
      );
      sq.y = this.calculatePosition(
        sq.initialY,
        sq.finalY,
        sq.longevity,
        this.step
      );
    }
  }
  calculatePosition(xS, xE, l, x) {
    const expo = (l, x) => {
      return x < l ? 1 - Math.pow(2, 10 * (x / l) - 10) : 0;
    };
    const val = (xS - xE) * expo(l, x) + xE;
    return val;
  }
  calculateOpacity(l, x) {
    return x <= l ? 1 - Math.pow(x / l, 1) : 0;
  }
}

const h1 = document.querySelectorAll("h1 span");

h1.forEach((el) => new TextDesintegrator(el));
    

// --------------------------------------





        window.requestAnimationFrame =

            window.__requestAnimationFrame ||

            window.requestAnimationFrame ||

            window.webkitRequestAnimationFrame ||

            window.mozRequestAnimationFrame ||

            window.oRequestAnimationFrame ||

            window.msRequestAnimationFrame ||

            (function () {

                return function (callback, element) {

                    var lastTime = element.__lastTime;

                    if (lastTime === undefined) {

                        lastTime = 0;

                    }

                    var currTime = Date.now();

                    var timeToCall = Math.max(1, 33 - (currTime - lastTime));

                    window.setTimeout(callback, timeToCall);

                    element.__lastTime = currTime + timeToCall;

                };

            })();

        window.isDevice = (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(((navigator.userAgent || navigator.vendor || window.opera)).toLowerCase()));

        var loaded = false;

        var init = function () {

            if (loaded) return;

            loaded = true;

            var mobile = window.isDevice;

            var koef = mobile ? 0.5 : 1;

            var canvas = document.getElementById('heart');

            var ctx = canvas.getContext('2d');

            var width = canvas.width = koef * innerWidth;

            var height = canvas.height = koef * innerHeight;

            var rand = Math.random;

            ctx.fillStyle = "rgba(0,0,0,1)";

            ctx.fillRect(0, 0, width, height);


            var heartPosition = function (rad) {

                //return [Math.sin(rad), Math.cos(rad)];

                return [Math.pow(Math.sin(rad), 3), -(15 * Math.cos(rad) - 5 * Math.cos(2 * rad) - 2 * Math.cos(3 * rad) - Math.cos(4 * rad))];

            };

            var scaleAndTranslate = function (pos, sx, sy, dx, dy) {

                return [dx + pos[0] * sx, dy + pos[1] * sy];

            };


            window.addEventListener('resize', function () {

                width = canvas.width = koef * innerWidth;

                height = canvas.height = koef * innerHeight;

                ctx.fillStyle = "rgba(0,0,0,1)";

                ctx.fillRect(0, 0, width, height);

            });


            var traceCount = mobile ? 20 : 50;

            var pointsOrigin = [];

            var i;

            var dr = mobile ? 0.3 : 0.1;

            for (i = 0; i < Math.PI * 2; i += dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i), 210, 13, 0, 0));

            for (i = 0; i < Math.PI * 2; i += dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i), 150, 9, 0, 0));

            for (i = 0; i < Math.PI * 2; i += dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i), 90, 5, 0, 0));

            var heartPointsCount = pointsOrigin.length;


            var targetPoints = [];

            var pulse = function (kx, ky) {

                for (i = 0; i < pointsOrigin.length; i++) {

                    targetPoints[i] = [];

                    targetPoints[i][0] = kx * pointsOrigin[i][0] + width / 2;

                    targetPoints[i][1] = ky * pointsOrigin[i][1] + height / 2;

                }

            };


            var e = [];

            for (i = 0; i < heartPointsCount; i++) {

                var x = rand() * width;

                var y = rand() * height;

                e[i] = {

                    vx: 0,

                    vy: 0,

                    R: 2,

                    speed: rand() + 5,

                    q: ~~(rand() * heartPointsCount),

                    D: 2 * (i % 2) - 1,

                    force: 0.2 * rand() + 0.7,

                    f: "hsla(0," + ~~(40 * rand() + 60) + "%," + ~~(60 * rand() + 20) + "%,.3)",

                    trace: []

                };

                for (var k = 0; k < traceCount; k++) e[i].trace[k] = { x: x, y: y };

            }


            var config = {

                traceK: 0.4,

                timeDelta: 0.01

            };


            var time = 0;

            var loop = function () {

                var n = -Math.cos(time);

                pulse((1 + n) * .5, (1 + n) * .5);

                time += ((Math.sin(time)) < 0 ? 9 : (n > 0.8) ? .2 : 1) * config.timeDelta;

                ctx.fillStyle = "rgba(0,0,0,.1)";

                ctx.fillRect(0, 0, width, height);

                for (i = e.length; i--;) {

                    var u = e[i];

                    var q = targetPoints[u.q];

                    var dx = u.trace[0].x - q[0];

                    var dy = u.trace[0].y - q[1];

                    var length = Math.sqrt(dx * dx + dy * dy);

                    if (10 > length) {

                        if (0.95 < rand()) {

                            u.q = ~~(rand() * heartPointsCount);

                        }

                        else {

                            if (0.99 < rand()) {

                                u.D *= -1;

                            }

                            u.q += u.D;

                            u.q %= heartPointsCount;

                            if (0 > u.q) {

                                u.q += heartPointsCount;

                            }

                        }

                    }

                    u.vx += -dx / length * u.speed;

                    u.vy += -dy / length * u.speed;

                    u.trace[0].x += u.vx;

                    u.trace[0].y += u.vy;

                    u.vx *= u.force;

                    u.vy *= u.force;

                    for (k = 0; k < u.trace.length - 1;) {

                        var T = u.trace[k];

                        var N = u.trace[++k];

                        N.x -= config.traceK * (N.x - T.x);

                        N.y -= config.traceK * (N.y - T.y);

                    }

                    ctx.fillStyle = u.f;

                    for (k = 0; k < u.trace.length; k++) {

                        ctx.fillRect(u.trace[k].x, u.trace[k].y, 1, 1);

                    }

                }

                //ctx.fillStyle = "rgba(255,255,255,1)";

                //for (i = u.trace.length; i--;) ctx.fillRect(targetPoints[i][0], targetPoints[i][1], 2, 2);


                window.requestAnimationFrame(loop, canvas);

            };

            loop();

        };


        var s = document.readyState;

        if (s === 'complete' || s === 'loaded' || s === 'interactive') init();

        else document.addEventListener('DOMContentLoaded', init, false);

    </script>

</body>

</html>